(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-58c0"],{2054:function(t,a,s){},3486:function(t,a,s){"use strict";s.r(a);var n=function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",[s("div",{class:{infoShow:this.$store.state.isInfoShow,infoHide:!this.$store.state.isInfoShow}},[s("Header"),s("div",{staticClass:"archive"},[s("div",{staticClass:"article-content"},[s("p",{staticClass:"fontA"},[t._v(t._s(t.artList.title))]),s("p",[t._v(t._s(t.artList.date))]),s("p",{staticClass:"fontE"},[t._v("函数")]),s("p",[t._v(" 调用带参数的函数")]),s("p",[t._v("   在调用函数时，您可以向其传递值，这些值被称为参数。")]),s("p",[t._v("   这些参数可以在函数中使用。")]),s("p",[t._v("   您可以发送任意多（ECMAScript最多 25 个）的参数，由逗号 (,) 分隔：")]),s("p",[t._v("   myFunction(argument1,argument2)")]),s("p",[t._v("  变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推")]),s("p",[t._v("  带有返回值的函数")]),s("p",[t._v(" 有时，我们会希望函数将值返回调用它的地方。")]),s("p",[t._v("   通过使用 return 语句就可以实现。")]),s("p",[t._v("   在使用 return 语句时，函数会停止执行，并返回指定的值。")]),s("p",[t._v("  在您仅仅希望退出函数时 ，也可使用 return 语句。返回值是可选的：")]),s("p",[t._v("  function myFunction(a,b){")]),s("p",{staticClass:"left20"},[t._v("  if (a>b){")]),s("p",{staticClass:"left40"},[t._v("   return;")]),s("p",{staticClass:"left20"},[t._v("     }")]),s("p",{staticClass:"left20"},[t._v("   x=a+b")]),s("p",[t._v("    }")]),s("p",[t._v("     如果 a 大于 b，则上面的代码将退出函数，并不会计算 a 和 b 的总和。")]),s("p",{staticClass:"fontE"},[t._v("   局部 JavaScript 变量")]),s("p",[t._v("   在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。\n              您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。\n              只要函数运行完毕，本地变量就会被删除。")]),s("p",{staticClass:"fontE"},[t._v("  全局 JavaScript 变量")]),s("p",[t._v(' 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。\n              \n              JavaScript 变量的生存期\n              JavaScript 变量的生命期从它们被声明的时间开始。\n              局部变量会在函数运行以后被删除。\n              全局变量会在页面关闭后被删除。\n              \n              向未声明的 JavaScript 变量来分配值\n              如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。\n              这条语句：carname="Volvo";\n              将声明一个全局变量 carname，即使它在函数内执行。\n              模拟函数重载  \n              用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载：')]),s("p",[t._v("  function doAdd() {")]),s("p",{staticClass:"left20"},[t._v("     if(arguments.length == 1) {")]),s("p",{staticClass:"left40"},[t._v("     alert(arguments[0] + 5);")]),s("p",{staticClass:"left40"},[t._v("     } else if(arguments.length == 2) {")]),s("p",{staticClass:"left40"},[t._v("      alert(arguments[0] + arguments[1]);")]),s("p",{staticClass:"left20"},[t._v("     }")]),s("p",[t._v("  }")]),s("p",[t._v('   doAdd(10);\t//输出 "15"')]),s("p",[t._v('  doAdd(40, 20);\t//输出 "60"')]),s("p",[t._v('   函数名只是指向函数对象的引用值，行为就像其他对象一样。,甚至可以使两个变量指向同一个函数.\n              var doAdd = new Function("iNum", "alert(iNum + 10)");\n              var alsodoAdd = doAdd;\n              doAdd(10);\t//输出 "20"\n              alsodoAdd(10);\t//输出 "20"\n              在这里，变量 doAdd 被定义为函数，然后 alsodoAdd 被声明为指向同一个函数的指针。用这两个变量都可以执行该函数的代码，并输出相同的结果 - "20"。因此，如果函数名只是指向函数的变量，那么可以把函数作为参数传递给另一个函数吗？回答是肯定的！\n            ')]),s("p",[t._v("  function callAnotherFunc(fnFunction, vArgument) {")]),s("p",{staticClass:"left20"},[t._v("   fnFunction(vArgument);")]),s("p",[t._v("  }")]),s("p",[t._v('  var doAdd = new Function("iNum", "alert(iNum + 10)");')]),s("p",[t._v('    callAnotherFunc(doAdd, 10);\t//输出 "20"')]),s("p",[t._v('   在上面的例子中，callAnotherFunc() 有两个参数 - 要调用的函数和传递给该函数的参数。这段代码把 doAdd() 传递给 callAnotherFunc() 函数，参数是 10，输出 "20"。\n              注意：尽管可以使用 Function 构造函数创建函数，但最好不要使用它，因为用它定义函数比用传统方式要慢得多。不过，所有函数都应看作 Function 类的实例。\n           ')]),s("p",[t._v("   Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。例如：")]),s("p",[t._v(" function doAdd(iNum) {")]),s("p",{staticClass:"left20"},[t._v("     alert(iNum + 10);")]),s("p",[t._v("    }")]),s("p",[t._v("    document.write(doAdd.toString());")]),s("p",[t._v("  //输出function doAdd(iNum) { alert(iNum + 10); }")]),s("br"),s("p",{staticClass:"fontE"},[t._v(" 闭包")]),s("p",[t._v("  闭包（closure），指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。\n              复杂的闭包实例。\n              在一个函数中定义另一个会使闭包变得更加复杂。例如：")]),s("p",[t._v(" var iBaseNum = 10;")]),s("p",[t._v(" function addNum(iNum1, iNum2) {")]),s("p",{staticClass:"left20"},[t._v("   function doAdd() { ")]),s("p",{staticClass:"left20"},[t._v("    return iNum1 + iNum2 + iBaseNum;")]),s("p",{staticClass:"left20"},[t._v("   }")]),s("p",{staticClass:"left20"},[t._v("  return doAdd();")]),s("p",[t._v("}")]),s("p",[t._v("   这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。\n              \n              这里要掌握的重要概念是，doAdd() 函数根本不接受参数，它使用的值是从执行环境中获取的。\n              \n              可以看到，闭包是 ECMAScript 中非常强大多用的一部分，可用于执行复杂的计算。\n              \n              提示：就像使用任何高级函数一样，使用闭包要小心，因为它们可能会变得非常复杂。")])])]),s("Footer")],1),s("Siteinfo")],1)},e=[],r=(s("3d40"),s("0418")),i=s("fd2d"),d=s("78d1"),o=s("7e2f"),c={data:function(){return{artList:""}},mounted:function(){this.getArticle()},components:{Header:r["a"],Footer:i["a"],Siteinfo:d["a"]},methods:{getArticle:function(){this.artList=o.art6}}},l=c,v=(s("3b9f"),s("2877")),p=Object(v["a"])(l,n,e,!1,null,"6290e0ea",null);p.options.__file="art6.vue";a["default"]=p.exports},"3b9f":function(t,a,s){"use strict";var n=s("2054"),e=s.n(n);e.a},"3d40":function(t,a,s){},"7e2f":function(t){t.exports={art10:{path:"art10",title:"一些小段子",date:"2018-8-22",tag:"other",orgAddress:""},art9:{path:"art9",title:"vuex基础概念",date:"2018-8-19",tag:"vue",orgAddress:""},art8:{path:"art8",title:"vue图片懒加载",date:"2018-7-30",tag:"vue",orgAddress:""},art7:{path:"art7",title:"封装继承多态抽象面向对象4大特性",date:"2018-7-21",tag:"js",orgAddress:""},art6:{path:"art6",title:"函数、闭包概念",date:"2018-6-22",tag:"js",orgAddress:""},art5:{path:"art5",title:"js学习记录",date:"2018-6-19",tag:"js",orgAddress:""},art4:{path:"art4",title:"通过数组filter（）方法选取指定的元素",date:"2018-5-30",tag:"js",orgAddress:""},art3:{path:"art3",title:"css常用命名",date:"2018-5-21",tag:"css",orgAddress:""},art2:{path:"art2",title:"HTML语义化标签",date:"2018-4-22",tag:"html",orgAddress:""},art1:{path:"art1",title:"css布局基础",date:"2018-4-19",tag:"css",orgAddress:""}}}}]);
//# sourceMappingURL=chunk-58c0.ae04e23a.js.map