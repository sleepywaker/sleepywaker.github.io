(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2c5b"],{"3d40":function(t,a,s){},"7be8":function(t,a,s){"use strict";var e=s("a981"),r=s.n(e);r.a},"7e2f":function(t){t.exports={art10:{path:"art10",title:"一些小段子",date:"2018-8-22",tag:"other",orgAddress:""},art9:{path:"art9",title:"vuex基础概念",date:"2018-8-19",tag:"vue",orgAddress:""},art8:{path:"art8",title:"vue图片懒加载",date:"2018-7-30",tag:"vue",orgAddress:""},art7:{path:"art7",title:"封装继承多态抽象面向对象4大特性",date:"2018-7-21",tag:"js",orgAddress:""},art6:{path:"art6",title:"函数、闭包概念",date:"2018-6-22",tag:"js",orgAddress:""},art5:{path:"art5",title:"js学习记录",date:"2018-6-19",tag:"js",orgAddress:""},art4:{path:"art4",title:"通过数组filter（）方法选取指定的元素",date:"2018-5-30",tag:"js",orgAddress:""},art3:{path:"art3",title:"css常用命名",date:"2018-5-21",tag:"css",orgAddress:""},art2:{path:"art2",title:"HTML语义化标签",date:"2018-4-22",tag:"html",orgAddress:""},art1:{path:"art1",title:"css布局基础",date:"2018-4-19",tag:"css",orgAddress:""}}},"881f":function(t,a,s){"use strict";s.r(a);var e=function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"main"},[s("div",{staticClass:"art-container"},[s("p",{staticClass:"fontA"},[t._v(t._s(t.art7.title))]),s("p",{staticClass:"fontE"},[t._v(t._s(t.art7.date))]),s("p",[t._v("一、封装性")]),s("p",[t._v("  封装就是把抽象出来的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作(成员方法)，才能对数据进行操作。\n                \n                　 JS封装只有两种状态，一种是公开的，一种是私有的。\n                    案例：")]),s("p",[t._v("    function Person(name,sal){")]),s("p",[t._v("       this.name=name;         //公开")]),s("p",[t._v("     var sal=sal;                 //私有")]),s("p",[t._v("      this.showInfo=function(){ //公开")]),s("p",[t._v('          window.alert(this.name+" "+sal);')]),s("p",[t._v("      }")]),s("p",[t._v("      function showInfo2(){      //把函数私有化")]),s("p",[t._v('        window.alert("你好"+this.name+" "+sal);')]),s("p",[t._v("      }")]),s("p",[t._v("  }")]),s("p",[t._v("  通过构造函数来分配成员方法，给每个对象分配一份独立的代码。这样的弊端就是如果对象实例有很多，那函数的资源占用就会很大，而且有可能造成内存泄漏。\n                通过prototype给所有的对象添加方法，但是这种方式不能去访问类的私有变量和方法。")]),s("router-link",{staticClass:"read-whole",attrs:{to:"art7"}},[t._v("阅读全文>>")])],1),s("div",{staticClass:"art-container"},[s("p",{staticClass:"fontA"},[t._v(t._s(t.art8.title))]),s("p",{staticClass:"fontE"},[t._v(t._s(t.art8.date))]),s("p",[t._v("    1、安装插件")]),s("p",[t._v("   npm install vue-lazyload – save")]),s("p",[t._v("   2、“src/main.js”引入插件,并使用use，设置参数（loading时显示图片）")]),s("p",[t._v("  import VueLazyLoad from 'vue-lazyload'")]),s("p",[t._v("  Vue.use(VueLazyLoad,{")]),s("p",[t._v('     loading:"/static/loading-svg/loading-bars.svg"')]),s("router-link",{staticClass:"read-whole",attrs:{to:"art8"}},[t._v("阅读全文>>")])],1),s("div",{staticClass:"art-container"},[s("p",{staticClass:"fontA"},[t._v(t._s(t.art9.title))]),s("p",{staticClass:"fontE"},[t._v(t._s(t.art9.date))]),s("p",[t._v("Vuex是一个专门为vue.js应用程序开发的状态管理模式（data函数内的变量称为状态）。\n\n            当构建一个大中型的单页面应用程序时，Vuex可以更好的帮助我们在组件外部统一管理状态。（可以理解为生成全局变量）\n            \n            Vuex核心概念\n            State ：State是唯一的数据源，单一状态树\n            Getters：通过getters可以派生出一些新的状态，基于state进行操作\n            Mutations：更改vuex的store中的状态的唯一方法是提交mutation\n            Actions：Action提交的是mutation，而不是直接变更状态；Action可以包含任意异步操作\n            Modules：面对复杂的应用程序，当管理的状态比较多时，我们需要将vuex的store对象分割成模块（modules）\n            ")]),s("router-link",{staticClass:"read-whole",attrs:{to:"art9"}},[t._v("阅读全文>>")])],1)])},r=[],n=(s("3d40"),s("7e2f")),i={data:function(){return{art7:"",art8:"",art9:""}},methods:{getArt:function(){this.art7=n.art7,this.art8=n.art8,this.art9=n.art9}},mounted:function(){this.getArt()}},o=i,d=(s("7be8"),s("2877")),l=Object(d["a"])(o,e,r,!1,null,"59e97663",null);l.options.__file="page3.vue";a["default"]=l.exports},a981:function(t,a,s){}}]);
//# sourceMappingURL=chunk-2c5b.bac62af0.js.map